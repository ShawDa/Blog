## Reference

[调优准备](https://github.com/superhj1987/pragmatic-java-engineer/blob/master/book/chapter8-profile/ready.md)

[Java调优常用命令](https://github.com/superhj1987/pragmatic-java-engineer/blob/master/book/appendix/java-profile.md)

## Content

### 1、业务层面，需要：

>* 了解系统的总体架构，明确压力方向。比如系统的哪一个接口、模块是使用率最高的，面临高并发的挑战
>* 构建测试环境来测试应用的性能，使用ab、loadrunner、jmeter、faban都可以
>* 对关键业务数据量进行分析，这里主要指的是对一些数据的量化分析，如数据库一天的数据量有多少、缓存的数据量有多大等
>* 了解系统的响应速度、吞吐量、TPS、QPS等指标需求，比如秒杀系统的相应速度和QPS是要求非常高的
>* 了解系统相关软件的版本、模式和参数等，有时候限于应用依赖服务的版本、模式等，性能也会受到一定的影响

### 2、Java内存管理

### 3、对Java代码进行基准性能测试

### 4、HotSpot虚拟机

> * HotSpot VM 主要由垃圾回收器、JIT 编译器和 Runtime 组成
> * HotSpot VM 的运行时架构包括类加载器、执行引擎以及运行时数据区，Java 源码被编译器编译为 JVM 字节码后进入 JVM, 由类加载器进行加载，并交给执行引擎执行，期间的数据都放入运行时数据区。其中 JIT 编译器是执行引擎中非常影响应用性能的组件，它会把热点代码直接编译为本地机器码，从而提高运行时的性能。此外，垃圾回收器执行 GC 的时机、效率对应用性能的影响也非常关键
> * HotSpot VM 内部有一些线程进行JVM的管理、监控、垃圾回收工作，主要包括 VM thread、Periodic task thread（该线程是JVM周期性任务调度的线程，它由 WatcherThread 创建，是一个单例对象）、Garbage collection threads（进行垃圾回收的线程）、JIT compiler threads（进行 JIT 编译的线程）、Signal dispatcher thread（当外部 jvm 命令接收成功后，会交给该线程去进行分发到各个不同的模块处理命令，并且返回处理结果）

### 5、系统性能调优

后端应用都是需要部署在服务器上的，因此在对 Java 应用调优之前务必先将系统的性能调整到一个相对较好的水平。

一般来说，目前后端系统都是部署在 Linux 主机上的，所以这里抛开 Win 系列不谈，对于 Linux 系统来说一般有以下配置关系着系统的性能：

> * 文件描述符数限制：Linux 中所有东西都是文件，一个 socket 就对应着一个文件描述符，因此系统配置的最大打开文件数以及单个进程能够打开的最大文件数就决定了 socket 的数目上限
> * 进程/线程数限制: 对于 Apache 使用的 prefork 等多进程模式，其负载能力由进程数目所限制；对 Tomcat 多线程模式则由线程数所限制
> * TCP 内核参数：网络应用的底层自然离不开 TCP/IP，Linux 内核有一些与此相关的配置也决定了系统的负载能力

#### 5.1、文件描述符限制

- 系统最大打开文件描述符数：

```shell
#临时性
echo 1000000 > /proc/sys/fs/file-max
#永久性：在/etc/sysctl.conf中设置
fs.file-max = 1000000
```

- 进程最大打开文件描述符数：这个是配置单个进程能够打开的最大文件数目，可以通过 `ulimit -n` 查看和修改。如果想要永久修改，则需要修改 `/etc/security/limits.conf` 中的 nofile 选项。

通过读取 `/proc/sys/fs/file-nr` 可以看到当前使用的文件描述符总数，对于文件描述符的配置，需要注意以下几点：

> * 所有进程打开的文件描述符数不能超过 `/proc/sys/fs/file-max`
> * 单个进程打开的文件描述符数不能超过 user limit 中 nofile 的 soft limit
> * nofile 的 soft limit 不能超过其 hard limit
> * nofile 的 hard limit 不能超过 `/proc/sys/fs/nr_open`

#### 5.2、进程/线程数限制

进程数限制：`ulimit -u` 可以查看/修改单个用户能够打开的最大进程数，/etc/security/limits.conf` 中的 noproc 则是系统的最大进程数。

线程数限制：

> * 可以通过 `/proc/sys/kernel/threads-max` 查看系统总共可以打开的最大线程数
> * 单个进程的最大线程数和 PTHREAD_THREADS_MAX 有关，此限制可以在 `/usr/include/bits/local_lim.h` 中查看,但是如果想要修改的话，需要重新编译 Linux 系统
> * 线程数的大小还受线程栈大小的制约：使用 `ulimit -s` 可以查看/修改线程栈的大小，即每开启一个新的线程需要分配给此线程的一部分内存，减小此值可以增加可以打开的线程数目

#### 5.3、TCP内核参数

在一台服务器 CPU 和内存资源有限的情况下，最大化压榨服务器的性能是最终目的。在节省成本的情况下，可以考虑修改 Linux 的内核 TCP/IP 参数来最大化压榨服务器的性能。如果通过修改内核参数也无法解决的负载问题，那只能考虑升级服务器。

可以通过以下命令查看当前 Linux 系统的各个状态网络连接的数目：

```shell
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
```

各状态中，TIME_WAIT 的连接数是需要注意的一点。此值过高会占用大量连接，影响系统的负载能力，因而需要调整参数以尽快的释放 TIME_WAIT 连接。

一般 TCP 相关的内核参数在 `/etc/sysctl.conf` 文件中，为了能够尽快释放 TIME_WAIT 状态的连接，可以做以下配置：

> * `net.ipv4.tcp_syncookies = 1`：表示开启 SYN Cookies。当出现 SYN 等待队列溢出时，启用 Cookies 来处理，可防范少量 SYN 攻击；默认为0，表示关闭
> * `net.ipv4.ip_local_port_range = 10000 65000`：表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000，这里需要注意不要将最低值设的太低，否则可能会占用掉正常的端口
> * `net.ipv4.tcp_max_syn_backlog = 8192`：表示 SYN 队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数
> * `net.ipv4.tcp_max_tw_buckets = 5000`：表示系统同时保持 TIME_WAIT 的最大数量，如果超过这个数字，TIME_WAIT 将立刻被清除并打印警告信息。默认为180000，改为5000，可以很好地减少 TIME_WAIT 套接字数量

### 6、系统和JDK诊断工具

#### 6.1、系统常用诊断工具

#### 6.2、JDK常用诊断工具