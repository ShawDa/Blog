### 1.泛型
泛型就是通过编写模板代码来适应任意类型，也可以在使用的时候指定类型。它的好处在于使用时不必对类型进行强制转换，可以通过编译器完成对类型的检查。

注意泛型的继承关系：可以把 `ArrayList<Integer>` 向上转型为 `List<Integer>`（类可以变），
但不能把 `ArrayList<Integer>` 向上转型为 `ArrayList<Number>`（T不能变成父类）。

泛型只在编译阶段有效。
```java
List<Integer> integerList = new ArrayList<>();
List<String> stringList = new ArrayList<>();
System.out.println(integerList.getClass().equals(stringList.getClass()));  // true
```
有上面的例子可以看出，java 的泛型只在编译阶段有效，之后会将相关信息擦拭，不会进入到运行时期。

### 2.泛型类
将泛型类型用于类中，这样定义的类被称为泛型类，如 `List`、 `Set` 和 `Map` 等。

```java
class Generic<T> {
    private T name;

    public Generic(T name) {
        this.name = name;
    }

    public T getName() {
        return name;
    }
}
```
上面是自定义的一个普通泛型类，在使用泛型类的时候可以传入泛型实参，也可以不传入，这样类型可以为任何类型。  
注意：泛型的参数类型只能是类（`Integer` 等），不能是基础类型（`int` 等）；

### 3.泛型接口
泛型接口与泛型类的定义和使用方法类似，常被用在各种类的 `generator` 中。

```java
interface Generator<T> {
    int size();

    T add(T element);
interface Generator<T> {
    int size();

    T add(T element);

    T remove(int index);
}

// 未传入泛型实参时，类也要申明泛型，否则编译报错：class MyGenerator implements Generator<T>
class MyGenerator<T> implements Generator<T> {
    @Override
    public int size() {
        return 0;
    }

    @Override
    public T add(T element) {
        return null;
    }

    @Override
    public T remove(int index) {
        return null;
    }
}

// 传入实参时，方法的泛型参数也要申明类型
class StringGenerator implements Generator<String> {
    private List<String> stringList = Arrays.asList("a", "b", "c");
    
    @Override
    public int size() {
        return stringList.size();
    }

    @Override
    public String add(String element) {
        stringList.add(element);
        return element;
    }

    @Override
    public String remove(int index) {
        return stringList.remove(index);
    }
}
    T remove(int index);
}
```

### 4.泛型通配符
`WHY？`  
Java 泛型的泛型没有协变和逆变特性。  
数组是可以协变的，比如 `Dog extends Animal`，那么 `Animal[]` 里面可以添加Dog对象。  
而集合是不能协变的，也就是说 `List<Animal>` 不是 `List<dog>` 的父类，这时候就可以用到通配符了。
```java
List<Number> numbers = new ArrayList<Integer>();  // Incompatible types. Found: 'java.util.ArrayList<java.lang.Integer>', required: 'java.util.List<java.lang.Number>'
List<? extends Number> extendNumbers = new ArrayList<Integer>();  // 使用泛型通配符，OK
```

#### 通配符主要有三类:
a. 无边界的通配符(Unbounded Wildcards), 就是 `<?>`, 比如 `List<?>`, 它的主要作用就是让泛型能够接受未知类型的数据。
```java
List<?> list = new ArrayList<>();
list.add(1);  // 'add(capture<?>)' in 'java.util.List' cannot be applied to '(int)'
list.add("abc");
list.add(null);  // 只有null是所有引用数据类型都具有的元素.
int a = list.get(1);
String b = list.get(2);  // Incompatible types. Found: 'capture<?>', required: 'java.lang.String'
Object c = list.get(3);  // 只能返回Object对象

List list1 = new ArrayList<>();
list1.add(2);  // Unchecked call to 'add(E)' as a member of raw type 'java.util.List'
Object d = list1.get(0);
```
由上例可以看到 `List<?>` 只能 `add null`，`get` 返回的是 `Object`；`List` 啥都能添加，但会有警告。

b. 固定上边界的通配符(Upper Bounded Wildcards), 使用它的泛型能够接受指定类及其子类类型的数据, 采用 `<? extends E>` 的形式声明使用该类通配符, 这里的 E 就是该泛型的上边界。