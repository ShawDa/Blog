### 1、概述

Java 的 volatile 关键字被用来修饰“被存储在主存中”的变量，更确切的说，每次读取 volatile 变量都是从主存中读而不是 CPU 缓存中，每次写 volatile 变量都会写到主存中而不仅仅是缓存中。（注意这里说的是在对变量修改的情况下。可见性是通过总线的通知机制实现：当某个线程修改了变量值，会标记缓存失效，CPU 到主存读取变量；未修改的情况下，若缓存中存在变量还是直接从缓存中直接读取）

### 2、变量可见性问题

Java 的 volatile 关键字保证了对各线程变量改变的可见性。

在一个多线程应用中，处于性能考虑，线程在操作非 volatile 变量时每个线程可能会将变量从主存拷贝到缓存中。若计算机有多个 CPU，那么每个线程可能会在不同的 CPU 中运行，这意味着每个线程都可能会把变量拷贝到各自缓存中：

![](imgs/java-volatile.png)

对于非 volatile 变量，JVM 并不保证会从主存中读取数据到缓存，或将缓存中的数据写入到主存中。

假设两个线程访问一个共享变量 count，若线程1修改了该变量值，但线程1和2都可能在某个时刻读取该值。如果 count 变量没有声明 volatile，那么修改的值不保证会从缓存中写回到主存，也就是缓存和主存中的变量值不一致。

这就是“可见性”问题，指的是线程看不到最新的变量值，因为其它线程还未将值写入主存，也就是一个线程的修改对其它的线程是不可见的。

### 3、volatile 可见性保证

将变量声明为 volatile，那么在写入时也会同时将变量值写入到主存中，在读取时会直接从主存中读取，保证变量的写入对其它线程可见。

上面的例子中，线程1修改了变量，线程2去读取该变量，将该变量声明为 volatile 就能保证线程1的写入对线程2是可见的。

然而，若两个线程都修改了变量的值，只声明 volatile 是不够的。

### 4、完整的 volatile 可见性保证

volatile 的可见性保证并不只对修饰的变量本身，还遵循以下原则：

> * 线程1写入某个 volatile 变量，线程2随后读取了该变量，那么线程1在写入 volatile 变量之前的所有可见的变量值在线程2读取 volatile 变量后都是可见的
> * 若线程1读取一个 volatile 变量，那么该线程中所有可见的变量同样从主存中重新读取

```java
public class Test {
    private int years;
    private int months;
    private volatile int days;

    public void update(int years, int months, int days){
        this.years  = years;
        this.months = months;
        this.days   = days;
    }
    
    public int totalDays() {
        int total = this.days;
        total += this.months * 30;
        total += this.years * 365;
        return total;
    }
}
```

`update()` 方法写入了3个变量，其中只有 days 变量是 volatile 的。完整的可见性保证意味着：在写入 days 变量时，其它两个变量也会被写入到主存中。`totalDays()` 中最开始读取 days 变量值，同时也会在主存中读取其它两个变量的值 。

可以将对 volatile 变量的读写理解为一个触发刷新的操作，写入时线程中的所有变量都会触发写入主存，而读取时也同样会触发这些变量从主存中读取。因此，应该尽量将 volatile 变量的写操作放在后面，读操作放在前面，这样就能连带其它变量一起刷新。若 `update()` 方法中先写入 days 变量，那么它会写入主存而其它两个就不会。若 `totalDays()` 方法中最后加上 days 变量，那么另外两个变量可能还是从缓存中而不是主存中读取的。

### 5、指令重排问题和 Happens-Before 保证

出于性能考量，JVM 和 CPU 是允许对程序中的指令进行重排的，只要保证重排后的指令语义一致即可，如以下代码：

```java
int a = 1;
int b = 2;
a++;
b++;
```

这些指令可以按照以下顺序重拍而不改变程序的语义：

```java
int a = 1;
a++;
int b = 2;
b++;
```

然而指令重排面临的一个问题就是对 volatile 变量的处理，如上一小节中的两个方法，如果 volatile 变量的位置被重拍了，那么就会导致程序语义的改变。

为了解决这个问题，volatile 关键字在可见性之外还提供了 happens-before 保证，原则如下：

> * 若有读写操作发生在写入 volatile 变量之前，那么这些操作指令不能被重排到写入 volatile 变量之后。也就是说，写入一个 volatile 变量之前的读写操作对该变量有 happens-before 保证。注意，若写入 volatile 变量之后有读写其它变量的操作，那么这些指令是有可能被重排到前面的，反之则不成立。
> * 若有读写操作发生在读取 volatile 变量之后，那么这些操作指令不能重排到读取 volatile 变量之前。注意，若读操作之前有读写其它变量的操作，那么这些操作指令是有可能被重排到后面的，反之则不成立。

以上的原则为 volatile 关键字的完整可见性提供了强制保证。

### 6、何时使用

volatile 关键字能保证变量的所有读取和写入都进入到主存中，但有些情况下仅仅将变量声明为 volatile 还是不够的。

当多个线程都能写入共享的 volatile 变量是主存也能储存正确的值，然而这有一个前提：变量新值得写入不能依赖于变量的旧值。也就是说，某个线程写入共享的 volatile 变量时，不需要先读取再计算后写入。

若多个线程要先读取 volatile 变量的值再计算后写入，那么该变量就不能保证正确的可见性。多个线程读写 volatile 变量的时间间隔很短，若它们同时读取了主存中相同的值，然后再计算出新的值写回到主存，那么就可能互相覆盖导致错误产生。

多线程对 volatile 变量 count 的自增操作就是这样的情形。若线程1将主存中的值0读取到其缓存中，然后自增1，但还没有写回主存。此时线程2在主存中读到的 count 值还是0，取回到其缓存中后同样自增为1，同样还未写回主存。

可以看到，线程1和2就是不同步的。count 的正确值应该为2，但两个 CPU 缓存中的值均为1而主存中的值认为0，即使两个值写回到主存中也是错的。

**那么，何时使用 volatile 关键字呢？**

若两个线程同时读写一个共享变量，可以使用 synchronized 来保证读写变量的原子性，也可以使用 `java.util.concurrent` 包里提供的许多原子数据类型。

如果只有一个线程对变量进行读写，而其它线程只是读取变量，那么将变量声明为 volatile 就可以保证读取的值为最新值。

### 7、性能考量

读写 volatile 变量会从主存中操作，这样会比从 CPU 缓存中读取代价更大。访问一个 volatile 变量同样会禁止指令重排，而指令重排是一种提升性能的技术。因此，我们应当只在需要保证变量可见性的情况下才使用 volatile 修饰符。



### Reference

[Java Volatile关键字](http://ifeve.com/java-volatile关键字/)

[Java Volatile Keyword](http://tutorials.jenkov.com/java-concurrency/volatile.html)