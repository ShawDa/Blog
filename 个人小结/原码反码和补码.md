这里涉及到的数字及运算均位于1个字节，也就是8bits来说的。

### 原码

最高位为符号位，0代表正数，1代表负数，非符号位为该数字绝对值的二进制表示：

**127: 0111 1111**

**-127: 1111 1111**



### 反码

正数的反码与原码一致；负数的反码最高位（符号位）不变，其余位按位取反：

**127: 0111 1111**

**-127: 1000 0000**



### 补码

正数的补码与原码一致；负数的补码是该数的反码加1：

**127: 0111 1111**

**-127: 1000 0001**



**计算机数字运算均基于补码。**

### Why？

若计算机运算时均用原码来表示，那么在进行加法和减法运算时，需要转化成两个绝对值的加减法运算。这样计算机既要实现加法器，又要实现减法器，代价比较大，为啥不用一个运算器来实现加减法的运算了？

当然可以，简单的想法就是化减法为加法。

举个例子，一个圆有360°，365°也就是5°，-30°也就是330°。这里的数字360表示圆的一周，在计算机里有个类似的概念叫做**模**，它可以**化减为加，本质是将溢出的部分舍去而不改变结果。**

可知单字节运算的模为256，若不算符号位：127+2 = 129（1000 0001），这就是-127的补码。可以看到，在单字节运算模式下，129表示-127，可以假设256为一圈，顺时针129和逆时针127是一样的。

**负数补码可以看成是模减去该数的绝对值。**

对于16-5这个运算，计算机这样处理：0001 0000 + 1111 1011 = 1 0000 1011，溢出位舍去，得到0000 1011 = 11。